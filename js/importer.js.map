{"version":3,"file":"importer.js","sources":["../components/importer/epub/actions.js","../components/importer/importer.js"],"sourcesContent":["const JSZip = window.JSZip\nconst BUCKET_URL = 'https://storage.googleapis.com/rebus-default-bucket/'\n\n// Context should be empty to begin with. Event should be a custom 'import:load' event. Its 'detail' property has only one property: 'file'\nasync function load (context = {}, event) {\n  // First we load the zip file and add it to the context. This loads it into memory so will fail with very large ebooks\n  const { base64 = false, file, DOMAIN } = event.detail\n  context.file = file\n  context.DOMAIN = DOMAIN\n  context.zip = await JSZip.loadAsync(file, { base64 })\n  // Then we find the META-INF/container.xml information file. This file tells us where the actual OPF file is.\n  const container = await context.zip\n    .file('META-INF/container.xml')\n    .async('string')\n  // I really shouldn't be using a regexp here but it works for the prototype. Should be replaced by proper parsing ASAP.\n  const result = container.match(/full-path=\"([^\"]+)\"/)\n  if (!result[1]) {\n    throw new Error('No OPF path found')\n  }\n  // We save the full path to the opf\n  context.opfPath = result[1]\n  // Let's save the file name\n  context.fileName = file.name\n  return context\n}\n\n// Do we need a handleError action at some point? Or does that belong to the component using the actions?\n\n// Do we need an unload action at some point? Or will de-referencing the context handle that?\n\n// This action parses the OPF and gets nav files from the zip in context and parses them into the 'publication' property as a 'rebus:Publication' type.\nasync function parse (context) {\n  const parser = new window.DOMParser()\n  // Get the OPF from the zip\n  const opf = await context.zip.file(context.opfPath).async('string')\n  // Parse the OPF into a DOM\n  let opfDoc = (context.opf = parser.parseFromString(opf, 'application/xml'))\n  if (opfDoc.querySelector('parsererror')) {\n    opfDoc = context.opf = parser.parseFromString(opf, 'text/html')\n    context.lang = getText(opfDoc.querySelector('dc\\\\:language'))\n    context.title = getText(opfDoc.querySelector('dc\\\\:title'))\n  } else {\n    context.lang = getText(opfDoc.querySelector('language'))\n    // Get the basic title (we'll handle alternate titles and refinements at a later date)\n    context.title = getText(opfDoc.querySelector('title'))\n  }\n  const packageElement = opfDoc.querySelector('package')\n  const idforid = packageElement.getAttribute('unique-identifier')\n  context.identifier = getText(opfDoc.getElementById(idforid))\n  // Discover if we're EPUB 2.0 or 3.0 or 3.1. This matters mostly for metadata details as _every_ single version handles metadata a bit differently. Thankfully we aren't supporting those metadata details in this release\n  context.epubVersion = packageElement.getAttribute('version')\n  // Find the HTML nav file for EPUB 3.0+\n  const htmlNavItem = opfDoc.querySelector('[properties~=nav]')\n  if (htmlNavItem) {\n    const htmlNavEntry = context.zip.file(\n      decodeURI(getPath(htmlNavItem.getAttribute('href'), context))\n    )\n    context.htmlNav = htmlNavEntry ? await htmlNavEntry.async('string') : null\n  }\n  // Find the NCX nav file if we don't have an HTML nav\n  if (!context.htmlNav) {\n    const ncxId = opfDoc.querySelector('spine').getAttribute('toc')\n    const ncxPath = getPath(\n      opfDoc.getElementById(ncxId).getAttribute('href'),\n      context\n    )\n    context.ncx = await context.zip.file(decodeURI(ncxPath)).async('string')\n  }\n  // Parse NCX file into HTML\n  // We are going to be generating a TOC from the chapters themselves in the prototype A so getting a proper ToC is not a priority for this release\n  // Generate a unique file prefix: `:userId/:bookId`\n  // Currently, client-side js doesn't have access to the user id (easy to fix later) so for prototype A we're just going to go for a random id for the book media\n  context.bookPrefix = `${Math.random()\n    .toFixed(8)\n    .replace('.', '')}/`\n  function getURL (path) {\n    return new window.URL(context.bookPrefix + path, BUCKET_URL)\n  }\n  // Create reference full URL for OPF using media upload target URL and prefix\n  // Currently hard-coded to the default bucket.\n  context.opfURL = getURL(context.opfPath)\n\n  // Goes through the resources and converts into a nice array of objects\n  // Each resource has an `activity` property that is a stub Activity Document object based on its media type and info in OPF with a reference URL based on the OPF URL and the OPF reference. Will either need to use something other than Array.from or add a polyfill later on for older browsers\n  context.attachment = Array.from(opfDoc.querySelectorAll('item'))\n    .map(item => {\n      const path = getPath(item.getAttribute('href'), context)\n      const href = getURL(path).href\n      const id = item.getAttribute('id')\n      const properties = item.getAttribute('properties') || ''\n      return {\n        path,\n        href,\n        id,\n        properties,\n        mediaType: item.getAttribute('media-type')\n      }\n    })\n    .map(itemToActivityStub)\n  // Update HTML toc to use proper URLs\n  // Not needed because we're ignoring the HTML toc for Prototype A\n  // This adds 'schema:position' to each activity. The API server has to use this to generate the `orderedItems` property as we cannot do so during import. Each item in the `orderedItems` property needs to refer to the id of a document in `attachment` but those ids don't exist until the document has been created serverside. So we need another mechanism.\n  const itemRefs = Array.from(\n    opfDoc.querySelectorAll('itemref:not([linear=\"no\"])')\n  )\n  itemRefs.forEach((element, index) => {\n    const item = context.attachment.filter(item => {\n      return item.id === element.getAttribute('idref')\n    })[0]\n    item.activity['position'] = index\n  })\n  context.totalItems = itemRefs.length\n  // Gets the creators (specific roles in later release)\n  // Contributors are a future feature\n  context.attributedTo = Array.from(opfDoc.querySelectorAll('creator')).map(\n    creator => {\n      return {\n        type: 'Person',\n        name: creator.textContent\n      }\n    }\n  )\n  // We need to then find the cover (which can be included in a variety of ways, unfortunately)\n  const propertiesCover = context.attachment.filter(item => {\n    return item.properties.indexOf('cover-image') !== -1\n  })[0]\n  const metaCover = opfDoc.querySelector('meta[name=\"cover\"]')\n  const guideCover = opfDoc.querySelector('guide reference[type=\"cover\"]')\n  const linearCover = opfDoc.querySelector('itemref')\n  let cover\n  if (propertiesCover) {\n    cover = propertiesCover\n  } else if (metaCover) {\n    cover = context.attachment.filter(item => {\n      return item.id === metaCover.getAttribute('content')\n    })[0]\n  } else if (guideCover) {\n    const coverHTML = context.attachment.filter(item => {\n      return item.path === getPath(guideCover.getAttribute('href'), context)\n    })[0]\n    if (coverHTML && coverHTML.mediaType.indexOf('image') !== -1) {\n      cover = coverHTML\n    } else if (coverHTML && coverHTML.path) {\n      const file = await context.zip\n        .file(decodeURI(coverHTML.path))\n        .async('string')\n      const fileDoc = parser.parseFromString(file, 'text/html')\n      const imageEl = fileDoc.querySelector('img')\n      if (imageEl) {\n        const src = imageEl.getAttribute('src')\n        const url = new window.URL(src, coverHTML.href).href\n        cover = context.attachment.filter(item => {\n          return item.href === url\n        })[0]\n      }\n    }\n  } else if (linearCover) {\n    const item = context.attachment.filter(item => {\n      return item.id === linearCover.getAttribute('idref')\n    })[0]\n    if (item && item.path) {\n      const file = await context.zip.file(decodeURI(item.path)).async('string')\n      const fileDoc = parser.parseFromString(file, 'text/html')\n      const imageEl = fileDoc.querySelector('img')\n      if (imageEl) {\n        const src = imageEl.getAttribute('src')\n        const url = new window.URL(src, item.href).href\n        cover = context.attachment.filter(item => {\n          return item.href === url\n        })[0]\n      }\n    }\n  }\n  if (cover) {\n    context.cover = cover\n  }\n  // Add link to final OPF destination URL as alternate\n  // Add link to uploaded EPUB file as alternate\n  context.url = [\n    {\n      type: 'Link',\n      href: getURL(context.fileName),\n      rel: ['alternate'],\n      mediaType: 'application/epub+zip'\n    }\n  ]\n  return context\n}\n\n// This action goes through all of the remaining html files in the epub, processes them for type\nasync function process (context, event) {\n  // Get the zip\n  const zip = context.zip\n  const parser = new window.DOMParser()\n  // For each resource we...\n  for (var index = 0; index < context.attachment.length; index++) {\n    const resource = context.attachment[index]\n    // Read it from the Zip file\n    if (resource.mediaType === 'application/xhtml+xml') {\n      const file = await zip.file(decodeURI(resource.path)).async('string')\n      resource.activity.content = file\n      // Just going to use this to extract data, hence the 'text/html'\n      const fileDoc = parser.parseFromString(file, 'text/html')\n      // Let's get the name! The first H1 would be the most sensible place to find it\n      const h1text = getText(fileDoc.querySelector('h1'))\n      // But sometimes book CMSes are extremely borked\n      const h2text = getText(fileDoc.querySelector('h2'))\n      // And they almost never have useful text in their title tags (you'd think they'd add something useful, but you'd be wrong). Let's grab it as a fallback anwyway.\n      const titleText = getText(fileDoc.querySelector('title'))\n      resource.activity.name = h1text || h2text || titleText\n    }\n  }\n  return context\n}\n\n// This uploads the initial file and all attachments using the file upload endpoint.\nasync function upload (context, event) {\n  const uploadFile = window.uploadFile\n  const zip = context.zip\n  // Another future feature is getting media sizes as they are being uploaded\n  // There are security implications for hosting unmodified html, css, and js files on a domain we control. So, we're only going to upload images and media. The long term solution is to sanitize the svg\n  // To upload, blobs need to be turned into File objects and added to a FormData object which becomes the payload.\n  // First upload the epub.\n  try {\n    const data = new window.FormData()\n    const filename = context.bookPrefix + context.file.name\n    const file = new window.File([context.file], filename, {\n      type: 'application/epub+zip'\n    })\n    console.log(file.name)\n    data.append('file', file)\n    data.append('name', filename)\n    await uploadFile(data)\n  } catch (err) {\n    console.log(err.response)\n  }\n  // Then cycle through the attachments and upload images, audio, video\n  for (var index = 0; index < context.attachment.length; index++) {\n    const resource = context.attachment[index]\n    const type = getType(resource.mediaType)\n    const blob = await zip.file(decodeURI(resource.path)).async('blob')\n    let sizes\n    if (type === 'image') {\n      try {\n        sizes = await getImageSizes(blob)\n        console.log(sizes)\n      } catch (err) {\n        console.log(err)\n      }\n    }\n    const filename = context.bookPrefix + decodeURI(resource.path)\n    const file = new window.File([blob], filename, { type: resource.mediaType })\n    const data = new window.FormData()\n    data.append('file', file)\n    data.append('type', type)\n    data.append('name', filename)\n    try {\n      const result = await uploadFile(data)\n      if (result.url) {\n        resource.activity.url[0].href = result.url\n      }\n      if (sizes) {\n        resource.activity.url[0].width = sizes.width\n        resource.activity.url[0].height = sizes.height\n      }\n    } catch (err) {\n      console.log(err)\n    }\n  }\n  if (\n    context.cover &&\n    context.cover.activity &&\n    context.cover.activity.url &&\n    context.cover.activity.url[0]\n  ) {\n    context.icon = {\n      type: 'Image',\n      summary: 'EPUB Cover',\n      url: context.cover.activity.url[0].href,\n      mediaType: context.cover.mediaType\n    }\n  }\n  return context\n}\n\n// Finally, this action prepares and submits the completed publication activity to the user's outbox.\nasync function create (context, event) {\n  const createPublication = window.createPublication\n  const publication = {\n    type: 'reader:Publication',\n    name: context.title\n  }\n  publication.attachment = context.attachment.map(item => item.activity)\n  // The the `publication` property in the context should now be a complete `rebus:Publication` activity.\n  publication.totalItems = context.totalItems\n  publication.attributedTo = context.attributedTo\n  if (context.icon) {\n    publication.icon = context.icon\n  }\n  publication.url = context.url\n  const wrapper = {\n    '@context': [\n      'https://www.w3.org/ns/activitystreams',\n      {\n        reader: 'https://rebus.foundation/ns/reader',\n        schema: 'https://schema.org/'\n      }\n    ],\n    type: 'Create',\n    object: publication\n  }\n  return createPublication(wrapper)\n}\n\nfunction getText (node) {\n  if (node) {\n    return node.textContent\n  } else {\n    return ''\n  }\n}\n\nfunction getPath (path, context) {\n  try {\n    const opf = new window.URL(context.opfPath, 'http://example.com/')\n    // Return the full pathname, sans initial '/' as that confuses the zip\n    return new window.URL(path, opf).pathname.replace('/', '')\n  } catch (err) {\n    console.log(err.message)\n    return null\n  }\n}\n\nfunction itemToActivityStub (item) {\n  item.activity = {}\n  if (item.mediaType.indexOf('image') !== -1) {\n    item.activity.type = 'Image'\n  } else if (item.mediaType.indexOf('audio') !== -1) {\n    item.activity.type = 'Audio'\n  } else if (item.mediaType.indexOf('video') !== -1) {\n    item.activity.type = 'Video'\n  } else {\n    item.activity.type = 'Document'\n  }\n  item.activity.url = [\n    {\n      type: 'Link',\n      href: item.href,\n      rel: ['alternate'],\n      mediaType: item.mediaType\n    }\n  ]\n  item.summary = `Resource of type ${item.mediaType}`\n  item.activity['reader:path'] = item.path\n  return item\n}\n\nfunction getImageSizes (blob) {\n  return new Promise((resolve, reject) => {\n    try {\n      const blobURL = URL.createObjectURL(blob)\n      const img = document.createElement('img')\n      img.src = blobURL\n      img.onload = () => {\n        const width = img.width\n        const height = img.height\n        return resolve({ width, height })\n      }\n    } catch (err) {\n      reject(err)\n    }\n  })\n}\n\nfunction getType (mediaType) {\n  if (mediaType.startsWith('image')) {\n    return 'Image'\n  } else if (mediaType.startsWith('audio')) {\n    return 'Audio'\n  } else if (mediaType.startsWith('video')) {\n    return 'Video'\n  } else if (mediaType === 'text/html') {\n    return 'html'\n  } else if (mediaType === 'application/xhtml+xml') {\n    return 'xhtml'\n  } else if (mediaType === 'application/xml') {\n    return 'xml'\n  } else if (mediaType.startsWith('text')) {\n    return 'generic-text'\n  }\n}\n\nexport const actions = { load, parse, process, upload, create }\n\nif (typeof module === 'object') {\n  module.exports.actions = actions\n}\n","import { actions } from './epub/actions.js'\nwindow.customElements.define(\n  'epub-import',\n  class EpubImportForm extends window.HTMLFormElement {\n    connectedCallback () {\n      this.addEventListener('change', this)\n      this.fileInput = this.querySelector('input[type=\"file\"]')\n    }\n    disconnectedCallback () {\n      this.removeEventListener('change', this)\n    }\n    async handleEvent (event) {\n      const file = this.fileInput.files[0]\n      const progress = this.querySelector('[data-upload-progress]')\n      console.log(file.name)\n      progress.textContent = `Loading ${file.name}`\n      const log = this.querySelector('[data-upload-log]')\n      try {\n        const context = await actions.load({}, { detail: { file } })\n        progress.textContent = `Parsing ${context.title}`\n        const parsed = await actions.parse(context)\n        progress.textContent = `Processing ${context.title}`\n        const processed = await actions.process(parsed)\n        progress.textContent = `Uploading media from ${context.title}`\n        const uploaded = await actions.upload(processed)\n        progress.textContent = `Creating ${context.title}`\n        const created = await actions.create(uploaded)\n        progress.textContent = ''\n        console.log(created)\n        const report = document.createElement('li')\n        report.innerHTML = `${\n          context.title\n        } has been added to your library <span class=\"Import-checkmark\">✔️</span>`\n        log.appendChild(report)\n      } catch (err) {\n        console.log(err)\n        const report = document.createElement('li')\n        report.innerHTML = `<pre><code>${err.stack}</pre></code>`\n        log.appendChild(report)\n      }\n    }\n  },\n  { extends: 'form' }\n)\n"],"names":["JSZip","window","BUCKET_URL","getText","node","textContent","getPath","path","context","opf","URL","opfPath","pathname","replace","err","console","log","message","itemToActivityStub","item","activity","mediaType","indexOf","type","url","href","rel","summary","getImageSizes","blob","Promise","resolve","reject","blobURL","createObjectURL","img","document","createElement","src","onload","width","height","actions","load","async","event","base64","file","DOMAIN","detail","zip","loadAsync","result","match","Error","fileName","name","parse","parser","DOMParser","opfDoc","parseFromString","querySelector","lang","title","packageElement","idforid","getAttribute","identifier","getElementById","epubVersion","htmlNavItem","htmlNavEntry","decodeURI","htmlNav","ncxId","ncxPath","ncx","getURL","bookPrefix","Math","random","toFixed","opfURL","attachment","Array","from","querySelectorAll","map","id","properties","itemRefs","forEach","element","index","filter","totalItems","length","attributedTo","creator","propertiesCover","metaCover","guideCover","linearCover","cover","coverHTML","imageEl","process","resource","content","fileDoc","h1text","h2text","titleText","upload","uploadFile","data","FormData","filename","File","append","response","startsWith","sizes","icon","create","createPublication","publication","@context","reader","schema","object","module","exports","customElements","define","HTMLFormElement","[object Object]","this","addEventListener","fileInput","removeEventListener","files","progress","parsed","processed","uploaded","created","report","innerHTML","appendChild","stack","extends"],"mappings":"AAAA,MAAMA,EAAQC,OAAOD,MACfE,EAAa,uDAyTnB,SAASC,EAASC,GAChB,OAAIA,EACKA,EAAKC,YAEL,GAIX,SAASC,EAASC,EAAMC,GACtB,IACE,MAAMC,EAAM,IAAIR,OAAOS,IAAIF,EAAQG,QAAS,uBAE5C,OAAO,IAAIV,OAAOS,IAAIH,EAAME,GAAKG,SAASC,QAAQ,IAAK,IACvD,MAAOC,GAEP,OADAC,QAAQC,IAAIF,EAAIG,SACT,MAIX,SAASC,EAAoBC,GAqB3B,OApBAA,EAAKC,SAAW,IACyB,IAArCD,EAAKE,UAAUC,QAAQ,SACzBH,EAAKC,SAASG,KAAO,SACyB,IAArCJ,EAAKE,UAAUC,QAAQ,SAChCH,EAAKC,SAASG,KAAO,SACyB,IAArCJ,EAAKE,UAAUC,QAAQ,SAChCH,EAAKC,SAASG,KAAO,QAErBJ,EAAKC,SAASG,KAAO,WAEvBJ,EAAKC,SAASI,IAAM,CAClB,CACED,KAAM,OACNE,KAAMN,EAAKM,KACXC,IAAK,CAAC,aACNL,UAAWF,EAAKE,YAGpBF,EAAKQ,4BAA8BR,EAAKE,YACxCF,EAAKC,SAAS,eAAiBD,EAAKZ,KAC7BY,EAGT,SAASS,EAAeC,GACtB,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAC3B,IACE,MAAMC,EAAUvB,IAAIwB,gBAAgBL,GAC9BM,EAAMC,SAASC,cAAc,OACnCF,EAAIG,IAAML,EACVE,EAAII,OAAS,MACX,MAAMC,EAAQL,EAAIK,MACZC,EAASN,EAAIM,OACnB,OAAOV,EAAQ,CAAES,MAAAA,EAAOC,OAAAA,MAE1B,MAAO3B,GACPkB,EAAOlB,MAuBN,MAAM4B,EAAU,CAAEC,KApYzBC,eAAqBpC,EAAU,GAAIqC,GAEjC,MAAMC,OAAEA,GAAS,EAAKC,KAAEA,EAAIC,OAAEA,GAAWH,EAAMI,OAC/CzC,EAAQuC,KAAOA,EACfvC,EAAQwC,OAASA,EACjBxC,EAAQ0C,UAAYlD,EAAMmD,UAAUJ,EAAM,CAAED,OAAAA,IAE5C,MAIMM,SAJkB5C,EAAQ0C,IAC7BH,KAAK,0BACLH,MAAM,WAEgBS,MAAM,uBAC/B,IAAKD,EAAO,GACV,MAAM,IAAIE,MAAM,qBAMlB,OAHA9C,EAAQG,QAAUyC,EAAO,GAEzB5C,EAAQ+C,SAAWR,EAAKS,KACjBhD,GAiXsBiD,MAzW/Bb,eAAsBpC,GACpB,MAAMkD,EAAS,IAAIzD,OAAO0D,UAEpBlD,QAAYD,EAAQ0C,IAAIH,KAAKvC,EAAQG,SAASiC,MAAM,UAE1D,IAAIgB,EAAUpD,EAAQC,IAAMiD,EAAOG,gBAAgBpD,EAAK,mBACpDmD,EAAOE,cAAc,gBACvBF,EAASpD,EAAQC,IAAMiD,EAAOG,gBAAgBpD,EAAK,aACnDD,EAAQuD,KAAO5D,EAAQyD,EAAOE,cAAc,kBAC5CtD,EAAQwD,MAAQ7D,EAAQyD,EAAOE,cAAc,iBAE7CtD,EAAQuD,KAAO5D,EAAQyD,EAAOE,cAAc,aAE5CtD,EAAQwD,MAAQ7D,EAAQyD,EAAOE,cAAc,WAE/C,MAAMG,EAAiBL,EAAOE,cAAc,WACtCI,EAAUD,EAAeE,aAAa,qBAC5C3D,EAAQ4D,WAAajE,EAAQyD,EAAOS,eAAeH,IAEnD1D,EAAQ8D,YAAcL,EAAeE,aAAa,WAElD,MAAMI,EAAcX,EAAOE,cAAc,qBACzC,GAAIS,EAAa,CACf,MAAMC,EAAehE,EAAQ0C,IAAIH,KAC/B0B,UAAUnE,EAAQiE,EAAYJ,aAAa,QAAS3D,KAEtDA,EAAQkE,QAAUF,QAAqBA,EAAa5B,MAAM,UAAY,KAGxE,IAAKpC,EAAQkE,QAAS,CACpB,MAAMC,EAAQf,EAAOE,cAAc,SAASK,aAAa,OACnDS,EAAUtE,EACdsD,EAAOS,eAAeM,GAAOR,aAAa,QAC1C3D,GAEFA,EAAQqE,UAAYrE,EAAQ0C,IAAIH,KAAK0B,UAAUG,IAAUhC,MAAM,UASjE,SAASkC,EAAQvE,GACf,OAAO,IAAIN,OAAOS,IAAIF,EAAQuE,WAAaxE,EAAML,GAJnDM,EAAQuE,cAAgBC,KAAKC,SAC1BC,QAAQ,GACRrE,QAAQ,IAAK,OAMhBL,EAAQ2E,OAASL,EAAOtE,EAAQG,SAIhCH,EAAQ4E,WAAaC,MAAMC,KAAK1B,EAAO2B,iBAAiB,SACrDC,IAAIrE,IACH,MAAMZ,EAAOD,EAAQa,EAAKgD,aAAa,QAAS3D,GAIhD,MAAO,CACLD,KAAAA,EACAkB,KALWqD,EAAOvE,GAAMkB,KAMxBgE,GALStE,EAAKgD,aAAa,MAM3BuB,WALiBvE,EAAKgD,aAAa,eAAiB,GAMpD9C,UAAWF,EAAKgD,aAAa,iBAGhCqB,IAAItE,GAIP,MAAMyE,EAAWN,MAAMC,KACrB1B,EAAO2B,iBAAiB,+BAE1BI,EAASC,QAAQ,CAACC,EAASC,KACZtF,EAAQ4E,WAAWW,OAAO5E,GAC9BA,EAAKsE,KAAOI,EAAQ1B,aAAa,UACvC,GACE/C,SAAmB,SAAI0E,IAE9BtF,EAAQwF,WAAaL,EAASM,OAG9BzF,EAAQ0F,aAAeb,MAAMC,KAAK1B,EAAO2B,iBAAiB,YAAYC,IACpEW,IACS,CACL5E,KAAM,SACNiC,KAAM2C,EAAQ9F,eAKpB,MAAM+F,EAAkB5F,EAAQ4E,WAAWW,OAAO5E,IACG,IAA5CA,EAAKuE,WAAWpE,QAAQ,gBAC9B,GACG+E,EAAYzC,EAAOE,cAAc,sBACjCwC,EAAa1C,EAAOE,cAAc,iCAClCyC,EAAc3C,EAAOE,cAAc,WACzC,IAAI0C,EACJ,GAAIJ,EACFI,EAAQJ,OACH,GAAIC,EACTG,EAAQhG,EAAQ4E,WAAWW,OAAO5E,GACzBA,EAAKsE,KAAOY,EAAUlC,aAAa,YACzC,QACE,GAAImC,EAAY,CACrB,MAAMG,EAAYjG,EAAQ4E,WAAWW,OAAO5E,GACnCA,EAAKZ,OAASD,EAAQgG,EAAWnC,aAAa,QAAS3D,IAC7D,GACH,GAAIiG,IAAuD,IAA1CA,EAAUpF,UAAUC,QAAQ,SAC3CkF,EAAQC,OACH,GAAIA,GAAaA,EAAUlG,KAAM,CACtC,MAAMwC,QAAavC,EAAQ0C,IACxBH,KAAK0B,UAAUgC,EAAUlG,OACzBqC,MAAM,UAEH8D,EADUhD,EAAOG,gBAAgBd,EAAM,aACrBe,cAAc,OACtC,GAAI4C,EAAS,CACX,MAAMpE,EAAMoE,EAAQvC,aAAa,OAC3B3C,EAAM,IAAIvB,OAAOS,IAAI4B,EAAKmE,EAAUhF,MAAMA,KAChD+E,EAAQhG,EAAQ4E,WAAWW,OAAO5E,GACzBA,EAAKM,OAASD,GACpB,UAGF,GAAI+E,EAAa,CACtB,MAAMpF,EAAOX,EAAQ4E,WAAWW,OAAO5E,GAC9BA,EAAKsE,KAAOc,EAAYpC,aAAa,UAC3C,GACH,GAAIhD,GAAQA,EAAKZ,KAAM,CACrB,MAAMwC,QAAavC,EAAQ0C,IAAIH,KAAK0B,UAAUtD,EAAKZ,OAAOqC,MAAM,UAE1D8D,EADUhD,EAAOG,gBAAgBd,EAAM,aACrBe,cAAc,OACtC,GAAI4C,EAAS,CACX,MAAMpE,EAAMoE,EAAQvC,aAAa,OAC3B3C,EAAM,IAAIvB,OAAOS,IAAI4B,EAAKnB,EAAKM,MAAMA,KAC3C+E,EAAQhG,EAAQ4E,WAAWW,OAAO5E,GACzBA,EAAKM,OAASD,GACpB,KAiBT,OAbIgF,IACFhG,EAAQgG,MAAQA,GAIlBhG,EAAQgB,IAAM,CACZ,CACED,KAAM,OACNE,KAAMqD,EAAOtE,EAAQ+C,UACrB7B,IAAK,CAAC,aACNL,UAAW,yBAGRb,GA8M6BmG,QA1MtC/D,eAAwBpC,EAASqC,GAE/B,MAAMK,EAAM1C,EAAQ0C,IACdQ,EAAS,IAAIzD,OAAO0D,UAE1B,IAAK,IAAImC,EAAQ,EAAGA,EAAQtF,EAAQ4E,WAAWa,OAAQH,IAAS,CAC9D,MAAMc,EAAWpG,EAAQ4E,WAAWU,GAEpC,GAA2B,0BAAvBc,EAASvF,UAAuC,CAClD,MAAM0B,QAAaG,EAAIH,KAAK0B,UAAUmC,EAASrG,OAAOqC,MAAM,UAC5DgE,EAASxF,SAASyF,QAAU9D,EAE5B,MAAM+D,EAAUpD,EAAOG,gBAAgBd,EAAM,aAEvCgE,EAAS5G,EAAQ2G,EAAQhD,cAAc,OAEvCkD,EAAS7G,EAAQ2G,EAAQhD,cAAc,OAEvCmD,EAAY9G,EAAQ2G,EAAQhD,cAAc,UAChD8C,EAASxF,SAASoC,KAAOuD,GAAUC,GAAUC,GAGjD,OAAOzG,GAoLsC0G,OAhL/CtE,eAAuBpC,EAASqC,GAC9B,MAAMsE,EAAalH,OAAOkH,WACpBjE,EAAM1C,EAAQ0C,IAKpB,IACE,MAAMkE,EAAO,IAAInH,OAAOoH,SAClBC,EAAW9G,EAAQuE,WAAavE,EAAQuC,KAAKS,KAC7CT,EAAO,IAAI9C,OAAOsH,KAAK,CAAC/G,EAAQuC,MAAOuE,EAAU,CACrD/F,KAAM,yBAERR,QAAQC,IAAI+B,EAAKS,MACjB4D,EAAKI,OAAO,OAAQzE,GACpBqE,EAAKI,OAAO,OAAQF,SACdH,EAAWC,GACjB,MAAOtG,GACPC,QAAQC,IAAIF,EAAI2G,UAGlB,IAAK,IAAI3B,EAAQ,EAAGA,EAAQtF,EAAQ4E,WAAWa,OAAQH,IAAS,CAC9D,MAAMc,EAAWpG,EAAQ4E,WAAWU,GAC9BvE,GAuIQF,EAvIOuF,EAASvF,WAwIlBqG,WAAW,SAChB,QACErG,EAAUqG,WAAW,SACvB,QACErG,EAAUqG,WAAW,SACvB,QACgB,cAAdrG,EACF,OACgB,0BAAdA,EACF,QACgB,oBAAdA,EACF,MACEA,EAAUqG,WAAW,QACvB,oBADF,EAnJC7F,QAAaqB,EAAIH,KAAK0B,UAAUmC,EAASrG,OAAOqC,MAAM,QAC5D,IAAI+E,EACJ,GAAa,UAATpG,EACF,IACEoG,QAAc/F,EAAcC,GAC5Bd,QAAQC,IAAI2G,GACZ,MAAO7G,GACPC,QAAQC,IAAIF,GAGhB,MAAMwG,EAAW9G,EAAQuE,WAAaN,UAAUmC,EAASrG,MACnDwC,EAAO,IAAI9C,OAAOsH,KAAK,CAAC1F,GAAOyF,EAAU,CAAE/F,KAAMqF,EAASvF,YAC1D+F,EAAO,IAAInH,OAAOoH,SACxBD,EAAKI,OAAO,OAAQzE,GACpBqE,EAAKI,OAAO,OAAQjG,GACpB6F,EAAKI,OAAO,OAAQF,GACpB,IACE,MAAMlE,QAAe+D,EAAWC,GAC5BhE,EAAO5B,MACToF,EAASxF,SAASI,IAAI,GAAGC,KAAO2B,EAAO5B,KAErCmG,IACFf,EAASxF,SAASI,IAAI,GAAGgB,MAAQmF,EAAMnF,MACvCoE,EAASxF,SAASI,IAAI,GAAGiB,OAASkF,EAAMlF,QAE1C,MAAO3B,GACPC,QAAQC,IAAIF,IA4GlB,IAAkBO,EA5FhB,OAZEb,EAAQgG,OACRhG,EAAQgG,MAAMpF,UACdZ,EAAQgG,MAAMpF,SAASI,KACvBhB,EAAQgG,MAAMpF,SAASI,IAAI,KAE3BhB,EAAQoH,KAAO,CACbrG,KAAM,QACNI,QAAS,aACTH,IAAKhB,EAAQgG,MAAMpF,SAASI,IAAI,GAAGC,KACnCJ,UAAWb,EAAQgG,MAAMnF,YAGtBb,GA8G8CqH,OA1GvDjF,eAAuBpC,EAASqC,GAC9B,MAAMiF,EAAoB7H,OAAO6H,kBAC3BC,EAAc,CAClBxG,KAAM,qBACNiC,KAAMhD,EAAQwD,OAqBhB,OAnBA+D,EAAY3C,WAAa5E,EAAQ4E,WAAWI,IAAIrE,GAAQA,EAAKC,UAE7D2G,EAAY/B,WAAaxF,EAAQwF,WACjC+B,EAAY7B,aAAe1F,EAAQ0F,aAC/B1F,EAAQoH,OACVG,EAAYH,KAAOpH,EAAQoH,MAE7BG,EAAYvG,IAAMhB,EAAQgB,IAYnBsG,EAXS,CACdE,WAAY,CACV,wCACA,CACEC,OAAQ,qCACRC,OAAQ,wBAGZ3G,KAAM,SACN4G,OAAQJ,MAqFU,iBAAXK,SACTA,OAAOC,QAAQ3F,QAAUA,GC1Y3BzC,OAAOqI,eAAeC,OACpB,cACA,cAA6BtI,OAAOuI,gBAClCC,oBACEC,KAAKC,iBAAiB,SAAUD,MAChCA,KAAKE,UAAYF,KAAK5E,cAAc,sBAEtC2E,uBACEC,KAAKG,oBAAoB,SAAUH,MAErCD,kBAAmB5F,GACjB,MAAME,EAAO2F,KAAKE,UAAUE,MAAM,GAC5BC,EAAWL,KAAK5E,cAAc,0BACpC/C,QAAQC,IAAI+B,EAAKS,MACjBuF,EAAS1I,uBAAyB0C,EAAKS,OACvC,MAAMxC,EAAM0H,KAAK5E,cAAc,qBAC/B,IACE,MAAMtD,QAAgBkC,EAAQC,KAAK,GAAI,CAAEM,OAAQ,CAAEF,KAAAA,KACnDgG,EAAS1I,uBAAyBG,EAAQwD,QAC1C,MAAMgF,QAAetG,EAAQe,MAAMjD,GACnCuI,EAAS1I,0BAA4BG,EAAQwD,QAC7C,MAAMiF,QAAkBvG,EAAQiE,QAAQqC,GACxCD,EAAS1I,oCAAsCG,EAAQwD,QACvD,MAAMkF,QAAiBxG,EAAQwE,OAAO+B,GACtCF,EAAS1I,wBAA0BG,EAAQwD,QAC3C,MAAMmF,QAAgBzG,EAAQmF,OAAOqB,GACrCH,EAAS1I,YAAc,GACvBU,QAAQC,IAAImI,GACZ,MAAMC,EAAShH,SAASC,cAAc,MACtC+G,EAAOC,aACL7I,EAAQwD,gFAEVhD,EAAIsI,YAAYF,GAChB,MAAOtI,GACPC,QAAQC,IAAIF,GACZ,MAAMsI,EAAShH,SAASC,cAAc,MACtC+G,EAAOC,wBAA0BvI,EAAIyI,qBACrCvI,EAAIsI,YAAYF,MAItB,CAAEI,QAAS"}